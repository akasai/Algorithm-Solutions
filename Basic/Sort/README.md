# Algorithms - Sort

## Insertion

### 시간 복잡도

|Best|Avg|Worst|
|:---:|:---:|:---:|
|O(n)|O(n^2)|O(n^2)|

* 배열의 모든 요소를 순차적으로 이미 정렬된 부분 배열과 비교하면서 위치를 찾아 삽입하는 방법

* 매 순서마다 요소를 삽입 위치를 찾고 해당 위치에 삽입

* 두 번째 요소부터 시작, 앞쪽의 자료들과 비교하여 삽입할 위치를 지정한 후 자료를 뒤로 옮기고 지정한 자리에 자료를 삽입

### 장점

* 안정한 정렬

* 레코드의 수가 적을 경우 효율적

* 어느정도 정렬되어 있는 경우에 매우 효율적

### 단점

* 요소들의 이동이 매우 많음

* 배열의 크기나 요소의 크기가 클 경우 비효율적

## Counting

### 시간 복잡도

|Best|Avg|Worst|
|:---:|:---:|:---:|
|O(n)|O(n)|O(n+k) (k는 배열에서 가장 큰 수)|

* 배열의 모든 요소들을 카운팅하고 이를 바탕으로 정렬

* 누적합을 바탕으로 비교연산 없는 안정정렬

* 특정 범위 안에서의 정렬일 경우 가장 효율적

   ex) 대표적으로 활용하는 사례는 26개의 알파벳으로 이루어진 문자열에서 Suffix Array를 얻는 경우
 

### 장점

* 안정한 정렬

* 레코드의 요소의 범위가 정해져 있거나 적을 경우가 적을 경우 효율적

### 단점

* 요소의 최대값이 클 수록 시간복잡도는 O(n!)까지도 가능

* 추가적인 메모리 공간을 필요로 함. 위의 상황일 경우 메모리 공간도 그 만큼 커짐
